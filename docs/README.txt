Админские команды:
Создать нового пользователя http://my.grasp.how/createNewUser/<login>/<password>/<admin secret>
Обновить пароль пользователя http://my.grasp.how/updateUserPassword/<login>/<password>/<admin_secret>
Удалить граф http://grasp.local/removeGraph/<graph id>/<admin_secret>

Из-под пользователя:
Создание нового графа http://grasp.local/createNewGraph?data={"name":"newName"}
Удалить граф http://grasp.local/removeGraph?data={"graph_id":"1234567"}
Скопировать граф вместе с историей http://grasp.local/copyGraph?data={"name":"newName","graph_id":"123456"}
Склонировать граф http://grasp.local/cloneGraph?data={"graph_id":"222","history_step":"333"}

Запуск тестов:
http://grasp.local/lib/client/jasmine/jasmin.php

Изменение типа узлов
1. Редактируем список типов в таблице graph
2. Редактируем соответствие типов и цветов в таблице graph_settings
3. Редактируем дефолтный граф (типы и соответствие цветов) в функции createNewGraph (appUserPkb.php)

##################### Условия на байесовский граф ##############################

1. Если факт, то есть поле soft evidence
(заполняется на основе источников данных, алгоритм вычисления reliability его не может менять).
Это же называется reliability. У факта может быть только две альтерантивы - факт верен и не верен.
Соответственно soft evidence задается в виде {"true":0.99, "false":"0.01"}
2. Если proposition, то есть поле априорная вероятность (человек его не может менять).
Изначально это поле равно 1/<кол-во альтернатив>. Потом вычисляется исходя из
soft evidence родителей и условных вероятностей P(proposition|родители)
3. У каждого следствия CHILD (=ребенка="узла с кружочком"), не важно факт это или proposition, есть условные вероятности
P(CHILD|родители) для каждой комбинации значений родителя. Заполняется человеком.
4. Любое proposition должно быть связано хотя бы с одним фактом или другим proposition. В графе должен быть хотя бы один факт.
5. Факты-причины (=факты-родители) должны быть независимы
6. Все следствия child1,child2,child3 причин parent1, parent2, ... должны быть независимы при parent1, parent2, ...
то есть P(child1,child2,child3|parent1, parent2, ... )=P(child1|parent1, parent2, ...)P(s2|parent1, parent2, ...)P(s3|parent1, parent2, ...)
7. Граф не должен содержать направленных циклов.


Простейший приближенный алгоритм вычисления вероятностей который можно реализовать в javascript работает следующим образом
1. Берутся все факты, для каждого генерируется его значение в соответствии с soft evidence.
2. Берутся вершины которые не являются ничьим ребенком (ни одно ребро не входит, все только выходят).
Если это факт для которого уже есть значение с шага 1. Если нет, то
генерируется значение альтернативы в соответствии с априорной вероятностью этой альтернативы.
 1 Цикл по всем детям - берется ребенок, всего его родители, для каждого родителя генерируется значение альтернативы
в соответствии с априорной вероятностью этой альтернативы (если еще не сгенерилось). Для факта эта вероятность берется из soft evidence.
 2 генерируется значение ребенка в соответствии с распределением P(child|parent1,parent2,...).
Если ребенок это факт, то он имеет сгенеренное значение на шаге 1. Если только что сгенеренное значение совпадает с этим,
то заносим в таблицу. Если нет, останавливаем цикл и переходим на шаг 1.
Если ребенок это proposition, то делаем для него шаг 2.1
3. Если мы находимся на этом шаге, значит мы сгенерили для узлов значения альтернатив, соответствующие soft evidence фактов.
Заносим этот вектор в таблицу consistentAlternativeValues. Если мы сделали шаг 3 уже 10000 раз
или consistentAlternativeValues содержит 1000 значений Идем на шаг 4.
4.Вероятность каждой альтернативы считается как
"кол-во её вхождений в consistentAlternativeValues"/"кол-во строк в consistentAlternativeValues"

Всего получается O(10000*(кол-во вершин в графе)) операций